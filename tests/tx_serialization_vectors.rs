// End-to-end canonical transaction serialization round-trip tests.
// This test is a placeholder demonstrating a deterministic round-trip: bytes -> hex -> bytes.
// Later we'll replace the vector below with a canonical signed EIP-1559 transaction.

use ethers::signers::{LocalWallet, Signer};
use ethers::types::transaction::eip2718::TypedTransaction;
use ethers::types::{Eip1559TransactionRequest, NameOrAddress, U256};
// hex crate used via functions; explicit import removed to satisfy clippy

// Construct a deterministic EIP-1559 tx, sign it with a fixed private key, and verify
// we can obtain a signed payload (raw bytes) from the wallet signing APIs.
#[tokio::test]
async fn test_eip1559_signed_tx_roundtrip() {
    // deterministic private key (32 bytes)
    let priv_key =
        hex::decode("0101010101010101010101010101010101010101010101010101010101010101").unwrap();
    let wallet = LocalWallet::from_bytes(&priv_key).expect("wallet").with_chain_id(1u64);

    // Build a simple EIP-1559 transaction request
    let to = NameOrAddress::Address("0x1111111111111111111111111111111111111111".parse().unwrap());
    let tx_req = Eip1559TransactionRequest {
        to: Some(to),
        value: Some(U256::from(1_000_000_000_000_000u64)),
        gas: Some(U256::from(21000u64)),
        max_fee_per_gas: Some(U256::from(20_000_000_000u64)),
        max_priority_fee_per_gas: Some(U256::from(1_000_000_000u64)),
        nonce: Some(U256::from(0u64)),
        ..Default::default()
    };

    // Wrap into a TypedTransaction
    let typed: TypedTransaction = tx_req.clone().into();

    // Sign the transaction - this yields a signature; also some ethers APIs can produce raw tx bytes.
    let sig = wallet.sign_transaction(&typed).await.expect("sign");

    // At minimum ensure signature components are present
    assert!(sig.r != U256::zero());

    // Re-encode signature to bytes and verify non-empty
    let sig_bytes = sig.to_vec();
    assert!(!sig_bytes.is_empty());
    // Try to obtain the signed raw transaction bytes via TypedTransaction helper
    // (some versions of ethers provide `rlp_signed` helpers)
    // typed.rlp_signed returns `ethers::types::Bytes` in this crate version
    let signed_bytes: Vec<u8> = typed.rlp_signed(&sig).to_vec();

    // We expect a deterministic canonical vector generated by `gen_eip1559_vector`.
    let canonical = "0x02f8728080843b9aca008504a817c80082520894111111111111111111111111111111111111111187038d7ea4c6800080c001a0691191bf06d248f41d30c17e4712b95e4b01998fdd97ec3b02784d7214002f7aa068c0c986842abcc69f3f79ea622e6c2e632b3a5ac90b6269f36a6bf7dcb92951";
    let hexed = format!("0x{}", hex::encode(&signed_bytes));
    assert_eq!(canonical.to_lowercase(), hexed.to_lowercase());
}
