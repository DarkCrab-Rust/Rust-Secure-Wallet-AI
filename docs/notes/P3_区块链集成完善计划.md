# 🔗 P3: 区块链集成完善计划 (Week 8-10)

## 📅 时间表
**开始时间**: 2025年10月24日  
**计划工期**: 3周 (Week 8-10)

---

## 📊 当前状态分析

### ✅ **已实现的功能**

#### **RPC集成** (基础完成)
- ✅ Ethereum客户端 (`EthereumClient`)
  - HTTP Provider with timeout
  - 代理支持 (HTTPS_PROXY, HTTP_PROXY)
  - ChainID自动检测
  - 网络识别 (Ethereum, Sepolia, Polygon, BSC)
- ✅ Solana客户端 (`SolanaClient`)
  - 基础RPC连接
- ✅ 交易发送
  - EIP-1559 support (Type-2 transactions)
  - 签名和广播
  - 交易哈希返回

#### **Gas管理** (部分完成)
- ✅ Gas价格获取 (`get_gas_price()`)
- ✅ Gas估算 (`estimate_fee()`)
- ✅ EIP-1559费用计算
  - `max_fee_per_gas = gas_price * 2`
  - `max_priority_fee_per_gas = gas_price / 10`
- ⚠️ 固定gas limit (21000) - 仅适用于ETH转账

#### **Nonce管理** (已实现)
- ✅ 数据库持久化 (`nonces`表)
- ✅ 原子性增量 (`reserve_next_nonce`)
- ✅ 网络隔离
- ✅ 地址隔离
- ✅ 并发安全 (UPSERT + 条件更新)

#### **交易状态** (基础完成)
- ✅ 交易状态查询 (`get_transaction_status`)
- ✅ 状态枚举 (Pending, Confirmed, Failed)
- ⚠️ 缺少确认数跟踪

---

## 🎯 改进目标

### **Week 8: RPC集成 + 交易跟踪**
1. ✨ **RPC连接池**
2. ✨ **RPC健康检查**
3. ✨ **交易跟踪系统**
4. ✨ **交易重试机制**

### **Week 9: Gas优化 + Nonce管理**
1. ✨ **智能Gas估算**
2. ✨ **Gas价格预言机**
3. ✨ **Nonce恢复机制**
4. ✨ **交易加速/取消**

### **Week 10: 事件监听**
1. ✨ **区块链事件监听**
2. ✨ **交易确认通知**
3. ✨ **Webhook支持**
4. ✨ **实时余额更新**

---

## 📋 详细实施计划

### **Week 8: RPC集成 + 交易跟踪** 🔗

#### **1. RPC连接池管理**

**目标**: 提高并发性能，降低延迟

**实现**:
```rust
// src/blockchain/rpc_pool.rs
pub struct RpcPool {
    providers: Vec<Arc<Provider<Http>>>,
    current_index: Arc<Mutex<usize>>,
    health_status: Arc<RwLock<HashMap<usize, HealthStatus>>>,
}

impl RpcPool {
    pub async fn new(endpoints: Vec<String>) -> Result<Self>;
    pub async fn get_provider(&self) -> Arc<Provider<Http>>;
    pub async fn health_check(&self) -> Result<()>;
    pub async fn rotate_to_healthy(&self) -> Arc<Provider<Http>>;
}
```

**特性**:
- 轮询负载均衡
- 自动故障转移
- 健康状态追踪
- 最小延迟选择

#### **2. RPC健康检查**

**目标**: 确保RPC节点可用性

**实现**:
```rust
#[derive(Debug, Clone)]
pub struct HealthStatus {
    pub is_healthy: bool,
    pub last_check: DateTime<Utc>,
    pub latency_ms: u64,
    pub error_count: u32,
}

impl EthereumClient {
    pub async fn health_check(&self) -> Result<HealthStatus> {
        let start = Instant::now();
        
        // Check 1: Get block number
        let _ = self.provider.get_block_number().await?;
        
        // Check 2: Get gas price
        let _ = self.get_gas_price().await?;
        
        let latency = start.elapsed().as_millis() as u64;
        
        Ok(HealthStatus {
            is_healthy: true,
            last_check: Utc::now(),
            latency_ms: latency,
            error_count: 0,
        })
    }
}
```

#### **3. 交易跟踪系统**

**目标**: 完整追踪交易生命周期

**数据库表**:
```sql
CREATE TABLE transaction_tracking (
    tx_hash TEXT PRIMARY KEY,
    wallet_id TEXT NOT NULL,
    network TEXT NOT NULL,
    status TEXT NOT NULL,
    confirmations INTEGER DEFAULT 0,
    required_confirmations INTEGER DEFAULT 12,
    submitted_at DATETIME NOT NULL,
    confirmed_at DATETIME,
    block_number INTEGER,
    FOREIGN KEY (wallet_id) REFERENCES wallets (id)
);

CREATE INDEX idx_tx_tracking_status ON transaction_tracking (status);
CREATE INDEX idx_tx_tracking_wallet ON transaction_tracking (wallet_id);
```

**实现**:
```rust
#[derive(Debug, Clone)]
pub struct TransactionTracker {
    storage: Arc<WalletStorage>,
    clients: HashMap<String, Box<dyn BlockchainClient>>,
}

impl TransactionTracker {
    pub async fn track_transaction(&self, tx_hash: &str, network: &str) -> Result<()>;
    pub async fn update_status(&self, tx_hash: &str) -> Result<TransactionStatus>;
    pub async fn wait_for_confirmation(&self, tx_hash: &str, confirmations: u32) -> Result<()>;
    pub async fn get_pending_transactions(&self) -> Result<Vec<TrackedTransaction>>;
}
```

#### **4. 交易重试机制**

**目标**: 处理临时失败，提高成功率

**实现**:
```rust
pub struct RetryConfig {
    pub max_retries: u32,
    pub initial_delay: Duration,
    pub backoff_multiplier: f32,
    pub max_delay: Duration,
}

impl EthereumClient {
    pub async fn send_with_retry(
        &self,
        private_key: &PrivateKey,
        to: &str,
        amount: &str,
        config: RetryConfig,
    ) -> Result<String, WalletError> {
        let mut attempt = 0;
        let mut delay = config.initial_delay;
        
        loop {
            match self.send_transaction(private_key, to, amount).await {
                Ok(tx_hash) => return Ok(tx_hash),
                Err(e) if attempt < config.max_retries => {
                    warn!("Transaction attempt {} failed: {}. Retrying in {:?}", attempt + 1, e, delay);
                    tokio::time::sleep(delay).await;
                    attempt += 1;
                    delay = Duration::min(
                        Duration::from_secs_f32(delay.as_secs_f32() * config.backoff_multiplier),
                        config.max_delay,
                    );
                }
                Err(e) => return Err(e),
            }
        }
    }
}
```

---

### **Week 9: Gas优化 + Nonce管理** ⚡

#### **1. 智能Gas估算**

**目标**: 根据交易类型动态估算Gas

**实现**:
```rust
pub enum TransactionType {
    NativeTransfer,
    Erc20Transfer,
    ContractCall { data: Vec<u8> },
    Swap,
}

impl EthereumClient {
    pub async fn estimate_gas_smart(
        &self,
        from: &str,
        to: &str,
        value: U256,
        data: Option<Vec<u8>>,
    ) -> Result<U256, WalletError> {
        // Use eth_estimateGas RPC call
        let from_addr = Address::from_str(from)?;
        let to_addr = Address::from_str(to)?;
        
        let tx = TransactionRequest::new()
            .from(from_addr)
            .to(to_addr)
            .value(value)
            .data(data.unwrap_or_default());
        
        let estimate = self.provider.estimate_gas(&tx.into(), None).await?;
        
        // Add 20% buffer for safety
        let buffered = estimate.saturating_mul(U256::from(120)) / U256::from(100);
        
        Ok(buffered)
    }
}
```

#### **2. Gas价格预言机**

**目标**: 根据网络状况智能调整Gas价格

**实现**:
```rust
pub struct GasOracle {
    provider: Arc<Provider<Http>>,
    cache: Arc<RwLock<GasPriceCache>>,
}

#[derive(Debug, Clone)]
pub struct GasPriceRecommendation {
    pub slow: U256,      // ~10+ minutes
    pub standard: U256,  // ~3 minutes
    pub fast: U256,      // ~30 seconds
    pub instant: U256,   // Next block
}

impl GasOracle {
    pub async fn get_gas_price(&self) -> Result<GasPriceRecommendation> {
        // Check cache first
        if let Some(cached) = self.cache.read().await.get() {
            if cached.age() < Duration::from_secs(15) {
                return Ok(cached.recommendation);
            }
        }
        
        // Fetch from network
        let base_fee = self.provider.get_block(BlockNumber::Latest).await?
            .and_then(|b| b.base_fee_per_gas)
            .unwrap_or(U256::from(1_000_000_000u64)); // 1 gwei fallback
        
        // Calculate recommendations
        let slow = base_fee + U256::from(1_000_000_000u64); // +1 gwei
        let standard = base_fee.saturating_mul(U256::from(110)) / U256::from(100); // +10%
        let fast = base_fee.saturating_mul(U256::from(125)) / U256::from(100); // +25%
        let instant = base_fee.saturating_mul(U256::from(150)) / U256::from(100); // +50%
        
        let recommendation = GasPriceRecommendation { slow, standard, fast, instant };
        
        // Update cache
        self.cache.write().await.update(recommendation.clone());
        
        Ok(recommendation)
    }
}
```

#### **3. Nonce恢复机制**

**目标**: 从错误状态恢复Nonce

**实现**:
```rust
impl WalletStorage {
    pub async fn sync_nonce_from_chain(
        &self,
        network: &str,
        address: &str,
        chain_nonce: u64,
    ) -> Result<()> {
        // 强制同步链上nonce
        let now = Utc::now().naive_utc();
        
        sqlx::query(r#"
            INSERT INTO nonces (network, address, next_nonce, updated_at)
            VALUES (?1, ?2, ?3, ?4)
            ON CONFLICT(network, address) DO UPDATE SET
                next_nonce = CASE
                    WHEN excluded.next_nonce > next_nonce THEN excluded.next_nonce
                    ELSE next_nonce
                END,
                updated_at = excluded.updated_at
        "#)
        .bind(network)
        .bind(address)
        .bind(chain_nonce as i64)
        .bind(now)
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }
    
    pub async fn reset_nonce(
        &self,
        network: &str,
        address: &str,
    ) -> Result<()> {
        sqlx::query("DELETE FROM nonces WHERE network = ?1 AND address = ?2")
            .bind(network)
            .bind(address)
            .execute(&self.pool)
            .await?;
        
        Ok(())
    }
}
```

#### **4. 交易加速/取消**

**目标**: 支持交易加速和取消操作

**实现**:
```rust
impl EthereumClient {
    /// 使用更高Gas价格重发交易（加速）
    pub async fn speed_up_transaction(
        &self,
        private_key: &PrivateKey,
        original_tx_hash: &str,
        gas_multiplier: f32, // e.g., 1.2 = 20% increase
    ) -> Result<String, WalletError> {
        // 1. 获取原始交易
        let original_tx = self.provider
            .get_transaction(H256::from_str(original_tx_hash)?)
            .await?
            .ok_or(WalletError::NotFound("Original transaction not found"))?;
        
        // 2. 使用相同nonce，更高gas价格
        let wallet = private_key.with_secret(|pk| self.create_wallet_from_private_key(pk))?;
        
        let new_gas_price = original_tx.gas_price
            .map(|gp| gp.saturating_mul(U256::from((gas_multiplier * 100.0) as u64)) / U256::from(100))
            .unwrap_or(self.get_gas_price().await?);
        
        let tx = Eip1559TransactionRequest {
            to: original_tx.to,
            value: original_tx.value,
            gas: original_tx.gas,
            nonce: original_tx.nonce,
            max_fee_per_gas: Some(new_gas_price.saturating_mul(U256::from(2))),
            max_priority_fee_per_gas: Some(new_gas_price / U256::from(10)),
            ..Default::default()
        };
        
        let client = SignerMiddleware::new(self.provider.clone(), wallet);
        let pending = client.send_transaction(tx, None).await?;
        
        Ok(format!("{:?}", pending.tx_hash()))
    }
    
    /// 发送0ETH交易到自己以取消pending交易
    pub async fn cancel_transaction(
        &self,
        private_key: &PrivateKey,
        nonce: u64,
    ) -> Result<String, WalletError> {
        let wallet = private_key.with_secret(|pk| self.create_wallet_from_private_key(pk))?;
        let self_address = wallet.address();
        
        // 发送0 ETH到自己，使用相同nonce和高gas价格
        let high_gas_price = self.get_gas_price().await?.saturating_mul(U256::from(2));
        
        let tx = Eip1559TransactionRequest {
            to: Some(NameOrAddress::Address(self_address)),
            value: Some(U256::zero()),
            gas: Some(U256::from(21000)),
            nonce: Some(U256::from(nonce)),
            max_fee_per_gas: Some(high_gas_price),
            max_priority_fee_per_gas: Some(high_gas_price / U256::from(10)),
            ..Default::default()
        };
        
        let client = SignerMiddleware::new(self.provider.clone(), wallet);
        let pending = client.send_transaction(tx, None).await?;
        
        Ok(format!("{:?}", pending.tx_hash()))
    }
}
```

---

### **Week 10: 事件监听** 👂

#### **1. 区块链事件监听器**

**目标**: 实时监听区块链事件

**实现**:
```rust
pub struct BlockchainEventListener {
    provider: Arc<Provider<Http>>,
    tracked_addresses: Arc<RwLock<HashSet<Address>>>,
    callbacks: Arc<Mutex<Vec<EventCallback>>>,
}

pub type EventCallback = Box<dyn Fn(BlockchainEvent) -> Pin<Box<dyn Future<Output = ()> + Send>> + Send + Sync>;

#[derive(Debug, Clone)]
pub enum BlockchainEvent {
    NewBlock { block_number: u64, timestamp: DateTime<Utc> },
    Transaction { tx_hash: H256, from: Address, to: Address, value: U256 },
    Confirmation { tx_hash: H256, confirmations: u32 },
}

impl BlockchainEventListener {
    pub async fn start(&self) -> Result<()> {
        let mut subscription = self.provider.subscribe_blocks().await?;
        
        while let Some(block) = subscription.next().await {
            self.handle_new_block(block).await?;
        }
        
        Ok(())
    }
    
    async fn handle_new_block(&self, block: Block<H256>) -> Result<()> {
        let event = BlockchainEvent::NewBlock {
            block_number: block.number.unwrap().as_u64(),
            timestamp: Utc::now(),
        };
        
        // 触发回调
        for callback in self.callbacks.lock().await.iter() {
            callback(event.clone()).await;
        }
        
        // 检查跟踪地址的交易
        for tx_hash in block.transactions {
            self.check_transaction(tx_hash).await?;
        }
        
        Ok(())
    }
}
```

#### **2. 交易确认通知**

**目标**: 在交易确认时通知用户

**实现**:
```rust
pub struct ConfirmationNotifier {
    tracker: Arc<TransactionTracker>,
    notifier: Arc<dyn Notifier>,
}

#[async_trait]
pub trait Notifier: Send + Sync {
    async fn notify(&self, notification: Notification) -> Result<()>;
}

#[derive(Debug, Clone)]
pub struct Notification {
    pub tx_hash: String,
    pub status: TransactionStatus,
    pub confirmations: u32,
    pub wallet_id: String,
}

impl ConfirmationNotifier {
    pub async fn monitor(&self) -> Result<()> {
        loop {
            let pending = self.tracker.get_pending_transactions().await?;
            
            for tx in pending {
                let status = self.tracker.update_status(&tx.tx_hash).await?;
                
                if let TransactionStatus::Confirmed { confirmations } = status {
                    if confirmations >= tx.required_confirmations {
                        self.notifier.notify(Notification {
                            tx_hash: tx.tx_hash.clone(),
                            status,
                            confirmations,
                            wallet_id: tx.wallet_id.clone(),
                        }).await?;
                    }
                }
            }
            
            tokio::time::sleep(Duration::from_secs(15)).await;
        }
    }
}
```

#### **3. Webhook支持**

**目标**: 支持HTTP Webhook通知

**实现**:
```rust
pub struct WebhookNotifier {
    client: reqwest::Client,
    webhook_urls: Vec<String>,
}

#[async_trait]
impl Notifier for WebhookNotifier {
    async fn notify(&self, notification: Notification) -> Result<()> {
        let payload = serde_json::to_value(&notification)?;
        
        for url in &self.webhook_urls {
            match self.client.post(url)
                .json(&payload)
                .timeout(Duration::from_secs(10))
                .send()
                .await
            {
                Ok(resp) if resp.status().is_success() => {
                    info!("Webhook delivered to {}: {:?}", url, notification);
                }
                Ok(resp) => {
                    warn!("Webhook failed with status {}: {}", resp.status(), url);
                }
                Err(e) => {
                    error!("Webhook error for {}: {}", url, e);
                }
            }
        }
        
        Ok(())
    }
}
```

#### **4. 实时余额更新**

**目标**: 在交易确认后更新余额缓存

**实现**:
```rust
pub struct BalanceCache {
    cache: Arc<RwLock<HashMap<(String, String), CachedBalance>>>, // (network, address) -> balance
}

#[derive(Debug, Clone)]
pub struct CachedBalance {
    pub balance: String,
    pub last_updated: DateTime<Utc>,
    pub block_number: u64,
}

impl BalanceCache {
    pub async fn update_on_confirmation(
        &self,
        network: &str,
        address: &str,
        client: &dyn BlockchainClient,
    ) -> Result<()> {
        let balance = client.get_balance(address).await?;
        let block_number = client.get_block_number().await?;
        
        self.cache.write().await.insert(
            (network.to_string(), address.to_string()),
            CachedBalance {
                balance,
                last_updated: Utc::now(),
                block_number,
            },
        );
        
        Ok(())
    }
    
    pub async fn get(&self, network: &str, address: &str) -> Option<CachedBalance> {
        self.cache.read().await
            .get(&(network.to_string(), address.to_string()))
            .cloned()
    }
}
```

---

## 📊 实施优先级

### **P0 - 必须完成**
- [ ] RPC健康检查
- [ ] 交易跟踪系统
- [ ] 智能Gas估算
- [ ] Nonce恢复机制

### **P1 - 高优先级**
- [ ] RPC连接池
- [ ] Gas价格预言机
- [ ] 交易加速/取消
- [ ] 交易确认通知

### **P2 - 中优先级**
- [ ] 事件监听器
- [ ] Webhook支持
- [ ] 余额缓存
- [ ] 交易重试机制

---

## 🎯 成功指标

- [ ] RPC响应时间 < 500ms (P95)
- [ ] RPC可用性 > 99.9%
- [ ] 交易成功率 > 98%
- [ ] Gas估算误差 < 5%
- [ ] Nonce冲突率 < 0.1%
- [ ] 事件通知延迟 < 30秒

---

**计划人员**: AI Blockchain Engineer  
**计划版本**: v0.1.0  
**计划日期**: 2025-10-24

