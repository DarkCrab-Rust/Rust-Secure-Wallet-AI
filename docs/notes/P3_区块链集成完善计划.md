# ğŸ”— P3: åŒºå—é“¾é›†æˆå®Œå–„è®¡åˆ’ (Week 8-10)

## ğŸ“… æ—¶é—´è¡¨
**å¼€å§‹æ—¶é—´**: 2025å¹´10æœˆ24æ—¥  
**è®¡åˆ’å·¥æœŸ**: 3å‘¨ (Week 8-10)

---

## ğŸ“Š å½“å‰çŠ¶æ€åˆ†æ

### âœ… **å·²å®ç°çš„åŠŸèƒ½**

#### **RPCé›†æˆ** (åŸºç¡€å®Œæˆ)
- âœ… Ethereumå®¢æˆ·ç«¯ (`EthereumClient`)
  - HTTP Provider with timeout
  - ä»£ç†æ”¯æŒ (HTTPS_PROXY, HTTP_PROXY)
  - ChainIDè‡ªåŠ¨æ£€æµ‹
  - ç½‘ç»œè¯†åˆ« (Ethereum, Sepolia, Polygon, BSC)
- âœ… Solanaå®¢æˆ·ç«¯ (`SolanaClient`)
  - åŸºç¡€RPCè¿æ¥
- âœ… äº¤æ˜“å‘é€
  - EIP-1559 support (Type-2 transactions)
  - ç­¾åå’Œå¹¿æ’­
  - äº¤æ˜“å“ˆå¸Œè¿”å›

#### **Gasç®¡ç†** (éƒ¨åˆ†å®Œæˆ)
- âœ… Gasä»·æ ¼è·å– (`get_gas_price()`)
- âœ… Gasä¼°ç®— (`estimate_fee()`)
- âœ… EIP-1559è´¹ç”¨è®¡ç®—
  - `max_fee_per_gas = gas_price * 2`
  - `max_priority_fee_per_gas = gas_price / 10`
- âš ï¸ å›ºå®šgas limit (21000) - ä»…é€‚ç”¨äºETHè½¬è´¦

#### **Nonceç®¡ç†** (å·²å®ç°)
- âœ… æ•°æ®åº“æŒä¹…åŒ– (`nonces`è¡¨)
- âœ… åŸå­æ€§å¢é‡ (`reserve_next_nonce`)
- âœ… ç½‘ç»œéš”ç¦»
- âœ… åœ°å€éš”ç¦»
- âœ… å¹¶å‘å®‰å…¨ (UPSERT + æ¡ä»¶æ›´æ–°)

#### **äº¤æ˜“çŠ¶æ€** (åŸºç¡€å®Œæˆ)
- âœ… äº¤æ˜“çŠ¶æ€æŸ¥è¯¢ (`get_transaction_status`)
- âœ… çŠ¶æ€æšä¸¾ (Pending, Confirmed, Failed)
- âš ï¸ ç¼ºå°‘ç¡®è®¤æ•°è·Ÿè¸ª

---

## ğŸ¯ æ”¹è¿›ç›®æ ‡

### **Week 8: RPCé›†æˆ + äº¤æ˜“è·Ÿè¸ª**
1. âœ¨ **RPCè¿æ¥æ± **
2. âœ¨ **RPCå¥åº·æ£€æŸ¥**
3. âœ¨ **äº¤æ˜“è·Ÿè¸ªç³»ç»Ÿ**
4. âœ¨ **äº¤æ˜“é‡è¯•æœºåˆ¶**

### **Week 9: Gasä¼˜åŒ– + Nonceç®¡ç†**
1. âœ¨ **æ™ºèƒ½Gasä¼°ç®—**
2. âœ¨ **Gasä»·æ ¼é¢„è¨€æœº**
3. âœ¨ **Nonceæ¢å¤æœºåˆ¶**
4. âœ¨ **äº¤æ˜“åŠ é€Ÿ/å–æ¶ˆ**

### **Week 10: äº‹ä»¶ç›‘å¬**
1. âœ¨ **åŒºå—é“¾äº‹ä»¶ç›‘å¬**
2. âœ¨ **äº¤æ˜“ç¡®è®¤é€šçŸ¥**
3. âœ¨ **Webhookæ”¯æŒ**
4. âœ¨ **å®æ—¶ä½™é¢æ›´æ–°**

---

## ğŸ“‹ è¯¦ç»†å®æ–½è®¡åˆ’

### **Week 8: RPCé›†æˆ + äº¤æ˜“è·Ÿè¸ª** ğŸ”—

#### **1. RPCè¿æ¥æ± ç®¡ç†**

**ç›®æ ‡**: æé«˜å¹¶å‘æ€§èƒ½ï¼Œé™ä½å»¶è¿Ÿ

**å®ç°**:
```rust
// src/blockchain/rpc_pool.rs
pub struct RpcPool {
    providers: Vec<Arc<Provider<Http>>>,
    current_index: Arc<Mutex<usize>>,
    health_status: Arc<RwLock<HashMap<usize, HealthStatus>>>,
}

impl RpcPool {
    pub async fn new(endpoints: Vec<String>) -> Result<Self>;
    pub async fn get_provider(&self) -> Arc<Provider<Http>>;
    pub async fn health_check(&self) -> Result<()>;
    pub async fn rotate_to_healthy(&self) -> Arc<Provider<Http>>;
}
```

**ç‰¹æ€§**:
- è½®è¯¢è´Ÿè½½å‡è¡¡
- è‡ªåŠ¨æ•…éšœè½¬ç§»
- å¥åº·çŠ¶æ€è¿½è¸ª
- æœ€å°å»¶è¿Ÿé€‰æ‹©

#### **2. RPCå¥åº·æ£€æŸ¥**

**ç›®æ ‡**: ç¡®ä¿RPCèŠ‚ç‚¹å¯ç”¨æ€§

**å®ç°**:
```rust
#[derive(Debug, Clone)]
pub struct HealthStatus {
    pub is_healthy: bool,
    pub last_check: DateTime<Utc>,
    pub latency_ms: u64,
    pub error_count: u32,
}

impl EthereumClient {
    pub async fn health_check(&self) -> Result<HealthStatus> {
        let start = Instant::now();
        
        // Check 1: Get block number
        let _ = self.provider.get_block_number().await?;
        
        // Check 2: Get gas price
        let _ = self.get_gas_price().await?;
        
        let latency = start.elapsed().as_millis() as u64;
        
        Ok(HealthStatus {
            is_healthy: true,
            last_check: Utc::now(),
            latency_ms: latency,
            error_count: 0,
        })
    }
}
```

#### **3. äº¤æ˜“è·Ÿè¸ªç³»ç»Ÿ**

**ç›®æ ‡**: å®Œæ•´è¿½è¸ªäº¤æ˜“ç”Ÿå‘½å‘¨æœŸ

**æ•°æ®åº“è¡¨**:
```sql
CREATE TABLE transaction_tracking (
    tx_hash TEXT PRIMARY KEY,
    wallet_id TEXT NOT NULL,
    network TEXT NOT NULL,
    status TEXT NOT NULL,
    confirmations INTEGER DEFAULT 0,
    required_confirmations INTEGER DEFAULT 12,
    submitted_at DATETIME NOT NULL,
    confirmed_at DATETIME,
    block_number INTEGER,
    FOREIGN KEY (wallet_id) REFERENCES wallets (id)
);

CREATE INDEX idx_tx_tracking_status ON transaction_tracking (status);
CREATE INDEX idx_tx_tracking_wallet ON transaction_tracking (wallet_id);
```

**å®ç°**:
```rust
#[derive(Debug, Clone)]
pub struct TransactionTracker {
    storage: Arc<WalletStorage>,
    clients: HashMap<String, Box<dyn BlockchainClient>>,
}

impl TransactionTracker {
    pub async fn track_transaction(&self, tx_hash: &str, network: &str) -> Result<()>;
    pub async fn update_status(&self, tx_hash: &str) -> Result<TransactionStatus>;
    pub async fn wait_for_confirmation(&self, tx_hash: &str, confirmations: u32) -> Result<()>;
    pub async fn get_pending_transactions(&self) -> Result<Vec<TrackedTransaction>>;
}
```

#### **4. äº¤æ˜“é‡è¯•æœºåˆ¶**

**ç›®æ ‡**: å¤„ç†ä¸´æ—¶å¤±è´¥ï¼Œæé«˜æˆåŠŸç‡

**å®ç°**:
```rust
pub struct RetryConfig {
    pub max_retries: u32,
    pub initial_delay: Duration,
    pub backoff_multiplier: f32,
    pub max_delay: Duration,
}

impl EthereumClient {
    pub async fn send_with_retry(
        &self,
        private_key: &PrivateKey,
        to: &str,
        amount: &str,
        config: RetryConfig,
    ) -> Result<String, WalletError> {
        let mut attempt = 0;
        let mut delay = config.initial_delay;
        
        loop {
            match self.send_transaction(private_key, to, amount).await {
                Ok(tx_hash) => return Ok(tx_hash),
                Err(e) if attempt < config.max_retries => {
                    warn!("Transaction attempt {} failed: {}. Retrying in {:?}", attempt + 1, e, delay);
                    tokio::time::sleep(delay).await;
                    attempt += 1;
                    delay = Duration::min(
                        Duration::from_secs_f32(delay.as_secs_f32() * config.backoff_multiplier),
                        config.max_delay,
                    );
                }
                Err(e) => return Err(e),
            }
        }
    }
}
```

---

### **Week 9: Gasä¼˜åŒ– + Nonceç®¡ç†** âš¡

#### **1. æ™ºèƒ½Gasä¼°ç®—**

**ç›®æ ‡**: æ ¹æ®äº¤æ˜“ç±»å‹åŠ¨æ€ä¼°ç®—Gas

**å®ç°**:
```rust
pub enum TransactionType {
    NativeTransfer,
    Erc20Transfer,
    ContractCall { data: Vec<u8> },
    Swap,
}

impl EthereumClient {
    pub async fn estimate_gas_smart(
        &self,
        from: &str,
        to: &str,
        value: U256,
        data: Option<Vec<u8>>,
    ) -> Result<U256, WalletError> {
        // Use eth_estimateGas RPC call
        let from_addr = Address::from_str(from)?;
        let to_addr = Address::from_str(to)?;
        
        let tx = TransactionRequest::new()
            .from(from_addr)
            .to(to_addr)
            .value(value)
            .data(data.unwrap_or_default());
        
        let estimate = self.provider.estimate_gas(&tx.into(), None).await?;
        
        // Add 20% buffer for safety
        let buffered = estimate.saturating_mul(U256::from(120)) / U256::from(100);
        
        Ok(buffered)
    }
}
```

#### **2. Gasä»·æ ¼é¢„è¨€æœº**

**ç›®æ ‡**: æ ¹æ®ç½‘ç»œçŠ¶å†µæ™ºèƒ½è°ƒæ•´Gasä»·æ ¼

**å®ç°**:
```rust
pub struct GasOracle {
    provider: Arc<Provider<Http>>,
    cache: Arc<RwLock<GasPriceCache>>,
}

#[derive(Debug, Clone)]
pub struct GasPriceRecommendation {
    pub slow: U256,      // ~10+ minutes
    pub standard: U256,  // ~3 minutes
    pub fast: U256,      // ~30 seconds
    pub instant: U256,   // Next block
}

impl GasOracle {
    pub async fn get_gas_price(&self) -> Result<GasPriceRecommendation> {
        // Check cache first
        if let Some(cached) = self.cache.read().await.get() {
            if cached.age() < Duration::from_secs(15) {
                return Ok(cached.recommendation);
            }
        }
        
        // Fetch from network
        let base_fee = self.provider.get_block(BlockNumber::Latest).await?
            .and_then(|b| b.base_fee_per_gas)
            .unwrap_or(U256::from(1_000_000_000u64)); // 1 gwei fallback
        
        // Calculate recommendations
        let slow = base_fee + U256::from(1_000_000_000u64); // +1 gwei
        let standard = base_fee.saturating_mul(U256::from(110)) / U256::from(100); // +10%
        let fast = base_fee.saturating_mul(U256::from(125)) / U256::from(100); // +25%
        let instant = base_fee.saturating_mul(U256::from(150)) / U256::from(100); // +50%
        
        let recommendation = GasPriceRecommendation { slow, standard, fast, instant };
        
        // Update cache
        self.cache.write().await.update(recommendation.clone());
        
        Ok(recommendation)
    }
}
```

#### **3. Nonceæ¢å¤æœºåˆ¶**

**ç›®æ ‡**: ä»é”™è¯¯çŠ¶æ€æ¢å¤Nonce

**å®ç°**:
```rust
impl WalletStorage {
    pub async fn sync_nonce_from_chain(
        &self,
        network: &str,
        address: &str,
        chain_nonce: u64,
    ) -> Result<()> {
        // å¼ºåˆ¶åŒæ­¥é“¾ä¸Šnonce
        let now = Utc::now().naive_utc();
        
        sqlx::query(r#"
            INSERT INTO nonces (network, address, next_nonce, updated_at)
            VALUES (?1, ?2, ?3, ?4)
            ON CONFLICT(network, address) DO UPDATE SET
                next_nonce = CASE
                    WHEN excluded.next_nonce > next_nonce THEN excluded.next_nonce
                    ELSE next_nonce
                END,
                updated_at = excluded.updated_at
        "#)
        .bind(network)
        .bind(address)
        .bind(chain_nonce as i64)
        .bind(now)
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }
    
    pub async fn reset_nonce(
        &self,
        network: &str,
        address: &str,
    ) -> Result<()> {
        sqlx::query("DELETE FROM nonces WHERE network = ?1 AND address = ?2")
            .bind(network)
            .bind(address)
            .execute(&self.pool)
            .await?;
        
        Ok(())
    }
}
```

#### **4. äº¤æ˜“åŠ é€Ÿ/å–æ¶ˆ**

**ç›®æ ‡**: æ”¯æŒäº¤æ˜“åŠ é€Ÿå’Œå–æ¶ˆæ“ä½œ

**å®ç°**:
```rust
impl EthereumClient {
    /// ä½¿ç”¨æ›´é«˜Gasä»·æ ¼é‡å‘äº¤æ˜“ï¼ˆåŠ é€Ÿï¼‰
    pub async fn speed_up_transaction(
        &self,
        private_key: &PrivateKey,
        original_tx_hash: &str,
        gas_multiplier: f32, // e.g., 1.2 = 20% increase
    ) -> Result<String, WalletError> {
        // 1. è·å–åŸå§‹äº¤æ˜“
        let original_tx = self.provider
            .get_transaction(H256::from_str(original_tx_hash)?)
            .await?
            .ok_or(WalletError::NotFound("Original transaction not found"))?;
        
        // 2. ä½¿ç”¨ç›¸åŒnonceï¼Œæ›´é«˜gasä»·æ ¼
        let wallet = private_key.with_secret(|pk| self.create_wallet_from_private_key(pk))?;
        
        let new_gas_price = original_tx.gas_price
            .map(|gp| gp.saturating_mul(U256::from((gas_multiplier * 100.0) as u64)) / U256::from(100))
            .unwrap_or(self.get_gas_price().await?);
        
        let tx = Eip1559TransactionRequest {
            to: original_tx.to,
            value: original_tx.value,
            gas: original_tx.gas,
            nonce: original_tx.nonce,
            max_fee_per_gas: Some(new_gas_price.saturating_mul(U256::from(2))),
            max_priority_fee_per_gas: Some(new_gas_price / U256::from(10)),
            ..Default::default()
        };
        
        let client = SignerMiddleware::new(self.provider.clone(), wallet);
        let pending = client.send_transaction(tx, None).await?;
        
        Ok(format!("{:?}", pending.tx_hash()))
    }
    
    /// å‘é€0ETHäº¤æ˜“åˆ°è‡ªå·±ä»¥å–æ¶ˆpendingäº¤æ˜“
    pub async fn cancel_transaction(
        &self,
        private_key: &PrivateKey,
        nonce: u64,
    ) -> Result<String, WalletError> {
        let wallet = private_key.with_secret(|pk| self.create_wallet_from_private_key(pk))?;
        let self_address = wallet.address();
        
        // å‘é€0 ETHåˆ°è‡ªå·±ï¼Œä½¿ç”¨ç›¸åŒnonceå’Œé«˜gasä»·æ ¼
        let high_gas_price = self.get_gas_price().await?.saturating_mul(U256::from(2));
        
        let tx = Eip1559TransactionRequest {
            to: Some(NameOrAddress::Address(self_address)),
            value: Some(U256::zero()),
            gas: Some(U256::from(21000)),
            nonce: Some(U256::from(nonce)),
            max_fee_per_gas: Some(high_gas_price),
            max_priority_fee_per_gas: Some(high_gas_price / U256::from(10)),
            ..Default::default()
        };
        
        let client = SignerMiddleware::new(self.provider.clone(), wallet);
        let pending = client.send_transaction(tx, None).await?;
        
        Ok(format!("{:?}", pending.tx_hash()))
    }
}
```

---

### **Week 10: äº‹ä»¶ç›‘å¬** ğŸ‘‚

#### **1. åŒºå—é“¾äº‹ä»¶ç›‘å¬å™¨**

**ç›®æ ‡**: å®æ—¶ç›‘å¬åŒºå—é“¾äº‹ä»¶

**å®ç°**:
```rust
pub struct BlockchainEventListener {
    provider: Arc<Provider<Http>>,
    tracked_addresses: Arc<RwLock<HashSet<Address>>>,
    callbacks: Arc<Mutex<Vec<EventCallback>>>,
}

pub type EventCallback = Box<dyn Fn(BlockchainEvent) -> Pin<Box<dyn Future<Output = ()> + Send>> + Send + Sync>;

#[derive(Debug, Clone)]
pub enum BlockchainEvent {
    NewBlock { block_number: u64, timestamp: DateTime<Utc> },
    Transaction { tx_hash: H256, from: Address, to: Address, value: U256 },
    Confirmation { tx_hash: H256, confirmations: u32 },
}

impl BlockchainEventListener {
    pub async fn start(&self) -> Result<()> {
        let mut subscription = self.provider.subscribe_blocks().await?;
        
        while let Some(block) = subscription.next().await {
            self.handle_new_block(block).await?;
        }
        
        Ok(())
    }
    
    async fn handle_new_block(&self, block: Block<H256>) -> Result<()> {
        let event = BlockchainEvent::NewBlock {
            block_number: block.number.unwrap().as_u64(),
            timestamp: Utc::now(),
        };
        
        // è§¦å‘å›è°ƒ
        for callback in self.callbacks.lock().await.iter() {
            callback(event.clone()).await;
        }
        
        // æ£€æŸ¥è·Ÿè¸ªåœ°å€çš„äº¤æ˜“
        for tx_hash in block.transactions {
            self.check_transaction(tx_hash).await?;
        }
        
        Ok(())
    }
}
```

#### **2. äº¤æ˜“ç¡®è®¤é€šçŸ¥**

**ç›®æ ‡**: åœ¨äº¤æ˜“ç¡®è®¤æ—¶é€šçŸ¥ç”¨æˆ·

**å®ç°**:
```rust
pub struct ConfirmationNotifier {
    tracker: Arc<TransactionTracker>,
    notifier: Arc<dyn Notifier>,
}

#[async_trait]
pub trait Notifier: Send + Sync {
    async fn notify(&self, notification: Notification) -> Result<()>;
}

#[derive(Debug, Clone)]
pub struct Notification {
    pub tx_hash: String,
    pub status: TransactionStatus,
    pub confirmations: u32,
    pub wallet_id: String,
}

impl ConfirmationNotifier {
    pub async fn monitor(&self) -> Result<()> {
        loop {
            let pending = self.tracker.get_pending_transactions().await?;
            
            for tx in pending {
                let status = self.tracker.update_status(&tx.tx_hash).await?;
                
                if let TransactionStatus::Confirmed { confirmations } = status {
                    if confirmations >= tx.required_confirmations {
                        self.notifier.notify(Notification {
                            tx_hash: tx.tx_hash.clone(),
                            status,
                            confirmations,
                            wallet_id: tx.wallet_id.clone(),
                        }).await?;
                    }
                }
            }
            
            tokio::time::sleep(Duration::from_secs(15)).await;
        }
    }
}
```

#### **3. Webhookæ”¯æŒ**

**ç›®æ ‡**: æ”¯æŒHTTP Webhooké€šçŸ¥

**å®ç°**:
```rust
pub struct WebhookNotifier {
    client: reqwest::Client,
    webhook_urls: Vec<String>,
}

#[async_trait]
impl Notifier for WebhookNotifier {
    async fn notify(&self, notification: Notification) -> Result<()> {
        let payload = serde_json::to_value(&notification)?;
        
        for url in &self.webhook_urls {
            match self.client.post(url)
                .json(&payload)
                .timeout(Duration::from_secs(10))
                .send()
                .await
            {
                Ok(resp) if resp.status().is_success() => {
                    info!("Webhook delivered to {}: {:?}", url, notification);
                }
                Ok(resp) => {
                    warn!("Webhook failed with status {}: {}", resp.status(), url);
                }
                Err(e) => {
                    error!("Webhook error for {}: {}", url, e);
                }
            }
        }
        
        Ok(())
    }
}
```

#### **4. å®æ—¶ä½™é¢æ›´æ–°**

**ç›®æ ‡**: åœ¨äº¤æ˜“ç¡®è®¤åæ›´æ–°ä½™é¢ç¼“å­˜

**å®ç°**:
```rust
pub struct BalanceCache {
    cache: Arc<RwLock<HashMap<(String, String), CachedBalance>>>, // (network, address) -> balance
}

#[derive(Debug, Clone)]
pub struct CachedBalance {
    pub balance: String,
    pub last_updated: DateTime<Utc>,
    pub block_number: u64,
}

impl BalanceCache {
    pub async fn update_on_confirmation(
        &self,
        network: &str,
        address: &str,
        client: &dyn BlockchainClient,
    ) -> Result<()> {
        let balance = client.get_balance(address).await?;
        let block_number = client.get_block_number().await?;
        
        self.cache.write().await.insert(
            (network.to_string(), address.to_string()),
            CachedBalance {
                balance,
                last_updated: Utc::now(),
                block_number,
            },
        );
        
        Ok(())
    }
    
    pub async fn get(&self, network: &str, address: &str) -> Option<CachedBalance> {
        self.cache.read().await
            .get(&(network.to_string(), address.to_string()))
            .cloned()
    }
}
```

---

## ğŸ“Š å®æ–½ä¼˜å…ˆçº§

### **P0 - å¿…é¡»å®Œæˆ**
- [ ] RPCå¥åº·æ£€æŸ¥
- [ ] äº¤æ˜“è·Ÿè¸ªç³»ç»Ÿ
- [ ] æ™ºèƒ½Gasä¼°ç®—
- [ ] Nonceæ¢å¤æœºåˆ¶

### **P1 - é«˜ä¼˜å…ˆçº§**
- [ ] RPCè¿æ¥æ± 
- [ ] Gasä»·æ ¼é¢„è¨€æœº
- [ ] äº¤æ˜“åŠ é€Ÿ/å–æ¶ˆ
- [ ] äº¤æ˜“ç¡®è®¤é€šçŸ¥

### **P2 - ä¸­ä¼˜å…ˆçº§**
- [ ] äº‹ä»¶ç›‘å¬å™¨
- [ ] Webhookæ”¯æŒ
- [ ] ä½™é¢ç¼“å­˜
- [ ] äº¤æ˜“é‡è¯•æœºåˆ¶

---

## ğŸ¯ æˆåŠŸæŒ‡æ ‡

- [ ] RPCå“åº”æ—¶é—´ < 500ms (P95)
- [ ] RPCå¯ç”¨æ€§ > 99.9%
- [ ] äº¤æ˜“æˆåŠŸç‡ > 98%
- [ ] Gasä¼°ç®—è¯¯å·® < 5%
- [ ] Nonceå†²çªç‡ < 0.1%
- [ ] äº‹ä»¶é€šçŸ¥å»¶è¿Ÿ < 30ç§’

---

**è®¡åˆ’äººå‘˜**: AI Blockchain Engineer  
**è®¡åˆ’ç‰ˆæœ¬**: v0.1.0  
**è®¡åˆ’æ—¥æœŸ**: 2025-10-24

